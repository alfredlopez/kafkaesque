package com.asanasoft.common;

import com.hazelcast.config.*;
import io.vertx.core.DeploymentOptions;
import io.vertx.core.Launcher;
import io.vertx.core.Vertx;
import io.vertx.core.VertxOptions;
import io.vertx.core.spi.cluster.ClusterManager;
import io.vertx.spi.cluster.hazelcast.HazelcastClusterManager;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.net.Inet4Address;
import java.net.InetAddress;
import java.net.NetworkInterface;
import java.net.SocketException;
import java.util.Enumeration;

public class MainLauncher extends Launcher {
    private Logger          logger          = LoggerFactory.getLogger(MainLauncher.class);
    private ClusterManager  clusterManager  = null;

    @Override
    public void beforeStartingVertx(VertxOptions options) {
        logger.debug("Main-Verticle = " + this.getMainVerticle());

        logger.info("Configuring cluster manager...");

        Config          hazelCastConfig = new ClasspathXmlConfig("cluster.xml");
        NetworkConfig   networkConfig   = hazelCastConfig.getNetworkConfig();
        JoinConfig      joinConfig      = networkConfig.getJoin();
        MulticastConfig multicastConfig = joinConfig.getMulticastConfig();
        TcpIpConfig     tcpIpConfig     = joinConfig.getTcpIpConfig();

//        multicastConfig.setEnabled(false);
//        tcpIpConfig.setEnabled(true);
//        tcpIpConfig.addMember(getMyIp());

        clusterManager  = new HazelcastClusterManager(hazelCastConfig);

        options.setClusterManager(clusterManager);

        /**
         * In order to turn clustering on, we must make sure that any ProxyServices are started ONCE per cluster.
         * So services like Bitsy should only start in one node. The alternative is to make the event bus local to the
         * node, which implies implementing the EB messaging manually instead of generated by the Vertx codegen.
         */
//        options.setClustered(true);
        options.setHAEnabled(false); //for now...
        options.setWorkerPoolSize(10);
        options.setBlockedThreadCheckInterval(1);
    }

    @Override
    public void afterStartingVertx(Vertx vertx) {
        logger.info("In afterStartingVertx...");

        logger.info("Storing cluster Manager in context...");
        vertx.getOrCreateContext().put("clusterManager", clusterManager);
    }

    @Override
    public void beforeDeployingVerticle(DeploymentOptions deploymentOptions) {
        logger.info("In beforeDeployingVerticle...");

        super.beforeDeployingVerticle(deploymentOptions);
    }

    protected String getMyIp() {
        String result = null;

        logger.debug("Getting my IP...");

        try {
            Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();

            while (interfaces.hasMoreElements()) {
                NetworkInterface iface = interfaces.nextElement();

                if (iface.isUp() && !iface.isLoopback() && !iface.isVirtual() && !iface.isPointToPoint()) {
                    Enumeration<InetAddress> addresses = iface.getInetAddresses();

                    boolean found = false;
                    while(addresses.hasMoreElements() && !found) {
                        InetAddress addr = addresses.nextElement();
                        if (Inet4Address.class == addr.getClass()) {
                            result = addr.getHostAddress();
                            found = true;
                        }
                    }
                }
            }
        }
        catch (SocketException e) {
            logger.error("An error occurred getting IP: ", e);
        }

        logger.debug("My IP is = " + result);

        return result;
    }

    public static void main(String[] args) {
        String[] myArgs = {"run", "com.asanasoft.app.kafkaesque.KafkaesqueApplication"};
        new MainLauncher().dispatch(myArgs);
    }
}
